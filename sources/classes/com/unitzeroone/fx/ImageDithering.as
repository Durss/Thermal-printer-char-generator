package com.unitzeroone.fx {	import flash.display.BitmapData;		import com.unitzeroone.util.BitmapDataUtil;	import com.unitzeroone.util.PaletteMapFactory;		/**	 * @author Ralph Hauwert	 * 	 * The ImageDithering class allows for simple image color quantization and dithering.	 * It aims to offer some well-known spatial dithering algorithms for the AS3 Language.	 * 	 * ralph@unitzeroone.com	 * http://www.unitzeroone.com	 */	final public class ImageDithering{				/**		 * dither(bitmapData:BitmapData, type:String, levels:int, grayscale:Boolean);		 * 		 * @param bitmapData the image to be color quantized and dithered.		 * @param type the dithering type. @see ImageDitheringType		 * @param levels The amount of "levels" per channel for color quantization.		 * @param grayscale if true, the image will be converted and treated as grayscale.		 */		public static function dither(bitmapData : BitmapData, type:String = "", levels:int = 1, grayscale : Boolean = true) : void {						if(grayscale){				BitmapDataUtil.desaturate(bitmapData);				}						switch(type){				case ImageDitheringType.FLOYD_STEINBERG:					applyFloydSteinberg(bitmapData, levels);				break;				case ImageDitheringType.FALSE_FLOYD_STEINBERG:					applyFalseFloydSteinberg(bitmapData, levels);				break;				case ImageDitheringType.STUCKI:					applyStucki(bitmapData, levels);				break;				case ImageDitheringType.NO_DITHER:					applyNoDither(bitmapData, levels);				break;				default:					applyFloydSteinberg(bitmapData, levels);				break;			}					}				/**		 * applyNoDither(bitmapData:BitmapData, levels:int);		 * 		 * This will only apply simple color quantisation. Purely for demo purposes.		 */		private static function applyNoDither(bitmapData:BitmapData, levels:int):void		{			PaletteMapFactory.createPosterizeMap(levels).applyTo(bitmapData);		}			/**		 * applyFloydSteinberg(bitmapData:BitmapData, levels:int);		 * 		 * Floyd-Steinberg dithering is an image dithering algorithm first published in 1976 by Robert W. Floyd and Louis Steinberg.		 * Using error diffusion, this form of dithering is visually much better then ordered diffusion like Bayer's.		 * R.W. Floyd, L. Steinberg, "An adaptive algorithm for spatial grey scale". Proceedings of the Society of Information Display 17, 75â€“77 (1976).		 */		private static function applyFloydSteinberg(bitmapData:BitmapData, levels:int) : void {			var lNorm:Number = 255/levels;						//The FS kernel...note the 16th. Optimisation can still be done.			var d1:Number = 7/16;			var d2:Number = 3/16;			var d3:Number = 5/16;			var d4:Number = 1/16;						var c:int, nc:int, lc:int;			var r:int,g:int,b:int;			var nr:int, ng:int, nb:int;			var er:int, eg:int, eb:int;			var lr:int, lg:int, lb:int;			var x:int = 0, y:int = 0;						for(y=0; y<bitmapData.height;y++){				for(x=0; x<=bitmapData.width;x++){					//Retrieve current RGB value.					c = bitmapData.getPixel(x, y);					r = c >> 16 &0xFF;					g = c >> 8 & 0xFF;					b = c & 0xFF;										//Normalize and scale to the number of levels.					//basically a cheap but suboptimal form of color quantization.					nr = Math.round((r/255) * levels) * lNorm;					ng = Math.round((g/255) * levels) * lNorm;					nb = Math.round((b/255) * levels) * lNorm;										//Set the current pixel.					nc = nr<<16|ng<<8|nb;					bitmapData.setPixel(x, y, nc);											//Quantization error.					er = r-nr;					eg = g-ng;					eb = b-nb;										//Apply the kernel.					//+1,0					lc = bitmapData.getPixel(x+1, y);					lr = (lc>>16&0xFF) + (d1*er);					lg = (lc>>8&0xFF) + (d1*eg);					lb = (lc&0xFF) + (d1*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+1, y, lr<<16 | lg << 8 | lb);										//-1,+1					lc = bitmapData.getPixel(x-1, y+1);					lr = (lc>>16&0xFF) + (d2*er);					lg = (lc>>8&0xFF) + (d2*eg);					lb = (lc&0xFF) + (d2*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x-1, y+1, lr<<16 | lg<<8 | lb);										//0,+1					lc = bitmapData.getPixel(x, y+1);					lr = (lc>>16&0xFF) + (d3*er);					lg = (lc>>8&0xFF) + (d3*eg);					lb = (lc&0xFF) + (d3*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x, y+1, lr<<16 | lg<< 8 | lb);										//+1,+1					lc = bitmapData.getPixel(x+1, y+1);					lr = (lc>>16&0xFF) + (d4*er);					lg = (lc>>8&0xFF) + (d4*eg);					lb = (lc&0xFF) + (d4*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+1, y+1, lr<<16 | lg << 8 | lb);						}			}		}				/**		 * applyFalseFloydSteinberg(bitmapData:BitmapData, levels:int);		 * 		 * falsely used as floydsteinberg in the past, this smaller kernel is faster then real floydsteinberg at a visual cost.		 */		private static function applyFalseFloydSteinberg(bitmapData : BitmapData, levels:int) : void {			var lNorm:Number = 255/levels;						//The FS kernel...note the 16th. Optimisation can still be done.			var d1:Number = 3/8;			var d2:Number = 3/8;			var d3:Number = 2/8;							var c:int, nc:int, lc:int;			var r:int,g:int,b:int;			var nr:int, ng:int, nb:int;			var er:int, eg:int, eb:int;			var lr:int, lg:int, lb:int;			var x:int = 0, y:int = 0;						for(y=0; y<bitmapData.height;y++){				for(x=0; x<=bitmapData.width;x++){					//Retrieve current RGB value.					c = bitmapData.getPixel(x, y);					r = c >> 16 &0xFF;					g = c >> 8 & 0xFF;					b = c & 0xFF;										//Normalize and scale to the number of levels.					//basically a cheap but suboptimal form of color quantization.					nr = Math.round((r/255) * levels) * lNorm;					ng = Math.round((g/255) * levels) * lNorm;					nb = Math.round((b/255) * levels) * lNorm;										//Set the current pixel.					nc = nr<<16|ng<<8|nb;					bitmapData.setPixel(x, y, nc);											//Quantization error.					er = r-nr;					eg = g-ng;					eb = b-nb;										//Apply the kernel.					//+1,0					lc = bitmapData.getPixel(x+1, y);					lr = (lc>>16&0xFF) + (d1*er);					lg = (lc>>8&0xFF) + (d1*eg);					lb = (lc&0xFF) + (d1*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+1, y, lr<<16 | lg << 8 | lb);										//0,+1					lc = bitmapData.getPixel(x, y+1);					lr = (lc>>16&0xFF) + (d2*er);					lg = (lc>>8&0xFF) + (d2*eg);					lb = (lc&0xFF) + (d2*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x, y+1, lr<<16 | lg<< 8 | lb);										//+1,+1					lc = bitmapData.getPixel(x+1, y+1);					lr = (lc>>16&0xFF) + (d3*er);					lg = (lc>>8&0xFF) + (d3*eg);					lb = (lc&0xFF) + (d3*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+1, y+1, lr<<16 | lg << 8 | lb);						}			}		}				/**		 * applyStucki(bitmapData:BitmapData, levels:int);		 * 		 * Created by P. Stucki, in 1981. It's an improvement of the Jarvis, Judice, and Ninke filter. This in turn is based upon FloydSteinberg kernel.		 * Much slower then FS, but finer since it spreads the error further and thus finer.		 */		private static function applyStucki(bitmapData : BitmapData, levels:int) : void {			var lNorm:Number = 255/levels;						/**			 * 			 * 			*   8   4    		 *	2   4   8   4   2    		 *	1   2   4   2   1 			 */			 			//The Stucki kernel...			var d1:Number = 8/42;			var d2:Number = 4/42;			var d3:Number = 2/42;			var d4:Number = 4/42;			var d5:Number = 8/42;			var d6:Number = 4/42;			var d7:Number = 2/42;			var d8:Number = 1/42;			var d9:Number = 2/42;			var d10:Number = 4/42;			var d11:Number = 2/42;			var d12:Number = 1/42;						var c:int, nc:int, lc:int;			var r:int,g:int,b:int;			var nr:int, ng:int, nb:int;			var er:int, eg:int, eb:int;			var lr:int, lg:int, lb:int;			var x:int = 0, y:int = 0;						for(y=0; y<bitmapData.height;y++){				for(x=0; x<=bitmapData.width;x++){					//Retrieve current RGB value.					c = bitmapData.getPixel(x, y);					r = c >> 16 &0xFF;					g = c >> 8 & 0xFF;					b = c & 0xFF;										//Normalize and scale to the number of levels.					//basically a cheap but suboptimal form of color quantization.					nr = Math.round((r/255) * levels) * lNorm;					ng = Math.round((g/255) * levels) * lNorm;					nb = Math.round((b/255) * levels) * lNorm;										//Set the current pixel.					nc = nr<<16|ng<<8|nb;					bitmapData.setPixel(x, y, nc);											//Quantization error.					er = r-nr;					eg = g-ng;					eb = b-nb;										//Apply the kernel.					//+1,0					lc = bitmapData.getPixel(x+1, y);					lr = (lc>>16&0xFF) + (d1*er);					lg = (lc>>8&0xFF) + (d1*eg);					lb = (lc&0xFF) + (d1*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+1, y, lr<<16 | lg << 8 | lb);										//+2,0					lc = bitmapData.getPixel(x+2, y);					lr = (lc>>16&0xFF) + (d2*er);					lg = (lc>>8&0xFF) + (d2*eg);					lb = (lc&0xFF) + (d2*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+2, y, lr<<16 | lg<< 8 | lb);										//-2,+1					lc = bitmapData.getPixel(x-2, y+1);					lr = (lc>>16&0xFF) + (d3*er);					lg = (lc>>8&0xFF) + (d3*eg);					lb = (lc&0xFF) + (d3*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x-2, y+1, lr<<16 | lg << 8 | lb);										//-1,+1					lc = bitmapData.getPixel(x-1, y+1);					lr = (lc>>16&0xFF) + (d4*er);					lg = (lc>>8&0xFF) + (d4*eg);					lb = (lc&0xFF) + (d4*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x-1, y+1, lr<<16 | lg << 8 | lb);										//0,+1					lc = bitmapData.getPixel(x, y+1);					lr = (lc>>16&0xFF) + (d5*er);					lg = (lc>>8&0xFF) + (d5*eg);					lb = (lc&0xFF) + (d5*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x, y+1, lr<<16 | lg << 8 | lb);										//+1,+1					lc = bitmapData.getPixel(x+1, y+1);					lr = (lc>>16&0xFF) + (d6*er);					lg = (lc>>8&0xFF) + (d6*eg);					lb = (lc&0xFF) + (d6*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+1, y+1, lr<<16 | lg << 8 | lb);										//+2,+1					lc = bitmapData.getPixel(x+2, y+1);					lr = (lc>>16&0xFF) + (d7*er);					lg = (lc>>8&0xFF) + (d7*eg);					lb = (lc&0xFF) + (d7*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+2, y+1, lr<<16 | lg << 8 | lb);										//-2,+2					lc = bitmapData.getPixel(x-2, y+2);					lr = (lc>>16&0xFF) + (d8*er);					lg = (lc>>8&0xFF) + (d8*eg);					lb = (lc&0xFF) + (d8*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x-2, y+2, lr<<16 | lg << 8 | lb);										//-1,+2					lc = bitmapData.getPixel(x-1, y+2);					lr = (lc>>16&0xFF) + (d9*er);					lg = (lc>>8&0xFF) + (d9*eg);					lb = (lc&0xFF) + (d9*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x-1, y+2, lr<<16 | lg << 8 | lb);										//0,+2					lc = bitmapData.getPixel(x, y+2);					lr = (lc>>16&0xFF) + (d10*er);					lg = (lc>>8&0xFF) + (d10*eg);					lb = (lc&0xFF) + (d10*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x, y+2, lr<<16 | lg << 8 | lb);										//+1,+2					lc = bitmapData.getPixel(x+1, y+2);					lr = (lc>>16&0xFF) + (d11*er);					lg = (lc>>8&0xFF) + (d11*eg);					lb = (lc&0xFF) + (d11*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+1, y+2, lr<<16 | lg << 8 | lb);										//+2,+2					lc = bitmapData.getPixel(x+2, y+2);					lr = (lc>>16&0xFF) + (d12*er);					lg = (lc>>8&0xFF) + (d12*eg);					lb = (lc&0xFF) + (d12*eb);					//Clip & Set					lr < 0 ? lr = 0: lr > 255 ? lr = 255 : lr;					lg < 0 ? lg = 0: lg > 255 ? lg = 255 : lg;					lb < 0 ? lb = 0: lb > 255 ? lb = 255 : lb;					bitmapData.setPixel(x+2, y+2, lr<<16 | lg << 8 | lb);					}			}		}			}}